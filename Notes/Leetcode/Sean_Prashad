$$BLIND 75$$

________________________________ARRAYS________________________________
______________________________________________________________________

-------------------------------------------------------------------------1. Two Sum (Easy)

sol1 - Brute Force 2 pointer solution--------------
class Solution {
    public int[] twoSum(int[] nums, int target) {
        int[] ans = new int[2];
        for(int i = 0; i < nums.length; i++) {
            int curr1 = nums[i];
            for(int j = i+1; j < nums.length; j++) {
                int curr2 = nums[j];
                if(curr1 + curr2 == target) {

                    ans[0] = i;
                    ans[1] = j;
                    return ans;
                }
            }
        }
        return ans;
    }
}
TIME: O(n^2)
SPACE: TODO

sol2 - hashmap--------------
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> visitedNumbers = new HashMap<>();
        for(int i = 0; i < nums.length; i++) {
            // x + y = target
            int delta = target - nums[i];
            if(visitedNumbers.containsKey(delta)) {
                return new int[] {i, visitedNumbers.get(delta)};
            }
            visitedNumbers.put(nums[i], i);
        }
        return new int[] {-1, -1};
    }
}
TIME: O(n)
SPACE: TODO

-----------------------------------------------121. Best Time to Buy and Sell Stock (Easy)

sol1 - Brute Force--------------
public class Solution {
    public int maxProfit(int prices[]) {
        int max = 0;
        for (int i = 0; i < prices.length - 1; i++) {
            for (int j = i + 1; j < prices.length; j++) {
                int profit = prices[j] - prices[i];
                if (profit > max)
                    max = profit;
            }
        }
        return max;
    }
}
TIME: O(n^2) - nested for loops so nested iterations present
SPACE: O(1) - only a few variables used to store data

sol3 - Dynamic Programming--------------
public class Solution {
    public int maxProfit(int[] prices) {
        int max = 0;
        int min = Integer.MAX_VALUE;

        for(int i = 0; i < prices.length; i++) {
            if(prices[i] < min) {
                min = prices[i];
            }
            else if(prices[i] - min > max) {
                max = prices[i] - min;
            }
        }
        return max;
    }
}
TIME: O(n) - Single iteration through, utilize max min data
SPACE: O(1) - only creating a couple variables for storing data.

sol3 - Two pointer efficient--------------
public class Solution {
    public int maxProfit(int[] prices) {
        int max = 0;
        if(prices.length == 0){
            return max;
        }
        int min=prices[0];
        for(int i = 1; i < prices.length; i++){
            if(prices[i] > min){
                if(max < (prices[i] - min)){
                    max=prices[i] - min;
                }
            }
            else{ min = prices[i]; }
        }
        return max;
    }
}
todo TIME:
todo SPACE:

------------------------------------------------------------217. Contains Duplicate (Easy)

sol1 - Brute Force - linear search took to long though--------------
class Solution {
    public boolean containsDuplicate(int[] nums) {
        int count = 0;

        for(int i = 0; i < nums.length - 1; i++) {
             for(int j = i + 1; j < nums.length; j++) {
                 if(nums[i] == nums[j]) {
                     return true;
                 }
             }
        }
        return false;
    }
}
todo TIME: O(n^2) -
todo SPACE: O(1) -

sol2 - Slightly better--------------
class Solution {
    Arrays.sort(nums);
    for(int i = 1; i < nums.length; i++) {
        if(nums[i] == nums[i - 1]) {
            return true;
        }
    }
    return false;
}
todo TIME: O(nlogn) -
todo SPACE: O(1) -

sol3 - Hashsets--------------
class Solution {
    public  boolean containsDuplicate(int[] nums) {
		 Set<Integer> set = new HashSet<Integer>();
		 for(int i : nums)
			 if(!set.add(i))// if there is same
				 return true;
		 return false;
	 }
}
todo TIME: O(n) -
todo SPACE: O(n) -

---------------------------------------------------------------53: Maximum Subarray (Easy)
sol1 - Dynamic Programming--------------
public int maxSubArray(int[] nums) {
        int currMax = nums[0];
        int overallMax = nums[0];

        for(int i = 1; i < nums.length; i++) {
            currMax = Math.max(nums[i], currMax + nums[i]);
            overallMax = Math.max(overallMax, currMax);
        }
        return overallMax;
}
todo TIME: O(n^2) -
todo SPACE: O(1) -

sol2 - Kadane's method--------------
public int maxSubArray(int[] nums) {
        int size = nums.length;
        int currMax = Integer.MIN_VALUE;
        int maxEndingHere = 0;

        for(int i = 0; i < size; i++) {
            maxEndingHere += nums[i];

            if(currMax < maxEndingHere) {
                currMax = maxEndingHere;
            }

            if(maxEndingHere < 0) {
                maxEndingHere = 0;
            }
        }
        return currMax;
}
todo TIME: O(n) -
todo SPACE: O(1) -

sol3 - improved-------------- do we actually have to compute EVERY sub array?
class Solution {
    public int maxSubArray(int[] nums) {
        int max = Integer.MIN_VALUE;
        int sum = 0;

        for(int i = 0; i < nums.length; i++) {
            sum = sum + nums[i]; // 0 = 0 + 4
            max = Math.max(sum, max);

            if(sum < 0) {sum = 0;}
        }
        return max;
    }
}
todo TIME: O(1) -
todo SPACE: O(n) -


----------------------------------------------------------------268: Missing Number (Easy)
sol1 - Linear Time solution VERY BAD--------------
class Solution {
    public int missingNumber(int[] nums) {
        //1. create set then fill it with the values
        HashSet<Integer> set = new HashSet<Integer>();
        for(int i: nums) {
            set.add(i);
        }

        //2. iterate through and compare input vals to set vals. return missing num if found
        for(int i = 0; i < nums.length; i++) {
            if(!set.contains(i)) {
                return i;
            }
        }
        //else return the next num in line
        return nums.length;
    }
}
TIME: O(n)
SPACE: O(n)

sol1 - Gausses rule, best solution--------------
class Solution {
    public int missingNumber(int[] nums) {
        int sum = 0;
        for(int i: nums) {
            sum += i;
        }

        int n = nums.length+1;
        return (n*(n-1)/2) - sum;
    }
}
TIME: O(1)
SPACE: O(1)


--------------------------------------448: Find All Numbers Disappeared in an Array (Easy)
sol1 - Using HashSet--------------
public List<Integer> findDisappearedNumbers(int[] nums) {

    //create list for results
    List<Integer> result = new ArrayList<Integer>();
    //create hashSet for reference
    HashSet<Integer> set = new HashSet<Integer>();
        //add all values to hashSet
        for(int num: nums) {
            set.add(num);
        }

        //iterate through and if value not in set, add to missing number result list
        for(int i = 1; i <= nums.length; i++) {
            if(!set.contains(i)) {
                result.add(i);
            }
        }

        return result;
    }
TODO TIME: O(n) - traversal of entire array once
TODO SPACE: O(n) - all numbers stored in array and hashtable

sol2 - use input array to not use extra memory--------------
public List<Integer> findDisappearedNumbers(int[] nums) {
        //create index for checking
        int index;
        //iterate through the array
        for(int i = 0; i < nums.length; i++) {
            //update index
            index = Math.abs(nums[i]) - 1;
            //
            if(nums[index] > 0) {
                nums[index] = nums[index] * -1;
            }
        }

        List<Integer> result = new ArrayList<Integer>();

        for(int i = 0; i < nums.length; i++) {
            //
            if(nums[i] > 0) {
                result.add(i+1);
            }
        }
        return result;
    }
TODO TIME: O(n) - Iterate through the array n times
TODO SPACE: O(1) - No extra space used as we reuse input structure

-----------------------------------------------------------------136: Single Number (Easy)
sol1a - using HashSet--------------
public int singleNumber(int[] nums) {
        Set<Integer> set = new HashSet<Integer>();
        //check if value is in set or not, only leave singles in set
        for(int i : nums) {
            if(set.contains(i)) {
                set.remove(i);
            }
            else {
                set.add(i);
            }
        }
        //iterate and return all values in set
        for(int i: set) {
            return i;
        }
        return -1;
}
*TODO TIME: O(n^2) -
*TODO SPACE: O(n) -

sol1b - using HashSet--------------
public int singleNumber(int[] nums) {
        Set<Integer> set = new HashSet<Integer>();
        // loop through input array
        for(int i = 0; i < nums.length; i++) {
            //if set contains the arrays current index value
            if(set.contains(nums[i])) {
                //remove from the set
                set.remove(nums[i]);
            }
            //add to the set
            else {
                set.add(nums[i]);
            }
        }
        //loop through input array
        for(int i = 0; i< nums.length; i++) {
            //if set contains the arrays current index value
            if(set.contains(nums[i])) {
                // return that index value
                return nums[i];
            }
        }
        return -1;
    }
TODO TIME: O(n^2) -
TODO SPACE: O(n) -

sol2 - bitwise--------------
public int singleNumber(int[] nums) {
    int ans =0;

    int len = nums.length;
    for(int i=0;i!=len;i++)
        ans ^= nums[i];

    return ans;
}
TODO TIME: O(?) -
TODO SPACE: O(?) -



------------------------------------------------2022: Convert 1D Array into 2D Array (Easy)
sol1 - todo--------------
public int[][] construct2DArray(int[] original, int m, int n) {
	if(original.length != m*n) return new int[0][0];
	int[][] result = new int[m][n];
	for(int i=0;i<original.length;i++)
		result[i/n][i%n] = original[i];
	return result;
}
TODO TIME: O(?) -
TODO SPACE: O(?) -

------------------------------------------------238: Product of Array Except Self (Medium)

sol1 - Passable solution--------------
class Solution {
    public int[] productExceptSelf(int[] nums) {
        //validity checker
        if(nums == null || nums.length == 0) return new int[0];

        int[] result = new int[nums.length];

        //running product
        int rp = 1;

        //left pass
        for(int i = 0; i < nums.length; i++) {
            result[i] = rp;
            rp = rp * nums[i];
        }

        //right pass
        rp = 1;

        for(int i = nums.length - 1; i >= 0; i--) {
            result[i] = result[i] * rp;
            rp = rp * nums[i];
        }

        return result;
    }
}
TIME: O(n) - We traverse through the array twice(left,right) which results in O(2n)==O(n)
SPACE: O(1) - Result array is only array used for calculations and is the only array returned.

TODO sol2 - Faster solution--------------




______________________________________________________________________
______________________________________________________________________


________________________________BINARY________________________________
______________________________________________________________________
---------------------------------------------------------371. Sum of Two Integers (Medium)
TODO

--------------191. Number of 1 Bits (Easy)--------------
sol1 - Brute Force--------------


TIME: TODO
SPACE: TODO



______________________________________________________________________
______________________________________________________________________

________________________________DYNAMIC PROGRAMMING________________________________
___________________________________________________________________________________

----------------------------------------------------------------70: Climbing Stairs (Easy)
sol1 - Brute Force--------------


TIME: TODO
SPACE: TODO


sol2 - The Fastest time complexity, not using array----------------
public int climbStairs(int n) {
    //base cases
    if(n == 1) return 1;
    if(n == 2) return 2;

    //rest
    int a = 1;
    int b = 2;
    int ways = 0;

    for(int i = 2; i < n; i++) {
        ways = a + b;
        a = b;
        b = ways;
    }
    return ways;
}
todo TIME: O(n)
todo SPACE: O(1)

sol3 - The Fastest time complexity, using array---------
public int climbStairs(int n) {
        int[] dp = new int[n+1];
        dp[0]=1;
        dp[1]=1;
        for(int i = 2; i <= n; i++) {
            dp[i] = dp[i-1] + dp[i-2];
        }
        return dp[n];
}
TIME: O(n)
SPACE: O(n)


---------------------------------------------------303: Range Sum Query - Immutable (easy)
sol1 - Dynamic Programming--------------

todo TIME: O(?)
todo SPACE: O(?)


-----------------------------------------------------------------322: Coin Change (Medium)
sol1 - Dynamic Programming--------------
public int coinChange(int[] coins, int amount) {
    Arrays.sort(coins); //small improvement
    int[] dp = new int[amount + 1]; //zero based so +1
    Arrays.fill(dp, amount + 1); //fill array w amount+1 in ea
    dp[0] = 0;

    //go up to end and include it
    for(int i = 0; i <= amount; i++) {
        for(int j = 0; j < coins.length; j++) {
            if(coins[j] <= i) {
                dp[i] = Math.min(dp[i], 1 + dp[i - coins[j]]);
            }
            else { //next small improvement
                break;
            }
        }
    }
    return dp[amount] > amount ? -1: dp[amount];

}
todo TIME: O(?)
todo SPACE: O(?)


----------------------------------------------------------------198: House Robber (Medium)
sol1 - DP--------------
 class Solution {
     public int rob(int[] nums) {
         // case 1: size of 0 or null
         if(nums == null || nums.length == 0) {
             return 0;
         }

         //case 2: size of 1
         if(nums.length == 1) {
             return nums[0];
         }

         //case 3: size of 2
         if(nums.length == 2) {
             return Math.max(nums[0], nums[1]);
         }

         //case 4: larger than 2
         int[] dp = new int[nums.length];
         dp[0] = nums[0];
         dp[1] = Math.max(nums[0], nums[1]);
         for(int i = 2; i < dp.length; i++) {
             dp[i] = Math.max(nums[i] + dp[i - 2], dp[i - 1]);
         }

         return dp[nums.length - 1];
     }
 }
TIME: TODO
SPACE: TODO

sol2 - TBD--------------

TIME: TODO
SPACE: TODO


___________________________________________________________________________________
___________________________________________________________________________________

________________________________Graph________________________________
_____________________________________________________________________

TODO

___________________________________________________________________________________
___________________________________________________________________________________

________________________________Interval________________________________
________________________________________________________________________

TODO

___________________________________________________________________________________
___________________________________________________________________________________

________________________________Linked List________________________________
___________________________________________________________________________

-----------------------------------------------------------206: Reverse Linked List (Easy)
sol1 - Brute Force, iterative--------------
NOTE: singly linked lists prevent traversing backwards so our solution requires us to keep track of the prev node.

public ListNode reverseList(ListNode head) {
        ListNode prev = null; //init pointer
        ListNode next = null; //init pointer

        while(head != null) {
            next = head.next; //save next
            head.next = prev; //reverse
            prev = head; //advance prev & head
            head = next; //advance prev & head
        }
        return prev; //new head at end
}
TIME: O(n)
SPACE: O(1) / O(n)

sol2 - Recursive--------------

// 1 -> 2 -> 3
// 3 -> 2 -> 1

public ListNode reverseList(ListNode head) {
    return reverseListInt(head, null);
}

public ListNode reverseListInt(ListNode head, ListNode newHead) {
    if(head == null) {return newHead;}
    ListNode next = head.next;
    head.next = newHead;
    return reverseListInt(next, head);
}
TIME: O(n)
SPACE: O(n)

-------------------------------------------------------------141: Linked List Cycle (Easy)
sol1 - HashMap -------------- TODO

TIME: TODO -
SPACE: TODO -

sol2 - Floyd's Tortoise & Hare Algorithm--------------
public class Solution {
    public boolean hasCycle(ListNode head) {
        //if invalid list, then no cycle
        if(head == null) return false;

        //create two list nodes which will act as slow and fast pointers respectively
        ListNode s = head;
        ListNode f = head;

        //while there are still valid nodes ahead for both s and f to move to...
        while(f.next != null && f.next.next != null) {

            //we will simply move the pointers to their next nodes
            s = s.next;
            f = f.next.next;

            //if our pointers meet at a similar node, then there is a cycle
            if(s == f) return true;
        }
        //if not, there is no cycle
        return false;
    }
}

TIME: O(n) -
SPACE: O(1) -


---------------------------------------------------------21: Merge Two Sorted Lists (Easy)
sol1 - iterative --------------
class Solution {
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        //creating our new list below
        ListNode dummy = new ListNode(-1);
        ListNode head = dummy;

        while(list1 != null && list2 != null) {
            //if value in list1 is less than value in list2
            if(list1.val < list2.val) {
                //we assign the next element in dummy list to list1s node
                dummy.next = list1;
                //we then move to the next list1 node
                list1 = list1.next;
            } else {
                //else we assign the next element in dummy list to list2s node
                dummy.next = list2;
                //we then move to the next list2 node
                list2 = list2.next;
            }
            dummy = dummy.next;
        }

        //if there are remaining elements in list 1, we append them to end
        if(list1 != null) {
            dummy.next = list1;
        } else {
            dummy.next = list2;
        }

        return head.next;
    }
}

TIME: O(n) - where n is the size of the smaller list... we only have n iterations in our while loop,
            then simply append the remaining list to our sorted list
SPACE: O(1) - we are only declaring a couple variables and are reusing the memory in all the list nodes

sol2 - TBD -------------- TODO

TIME: TODO -
SPACE: TODO -



sol3 - iterative leetcode comment-------------------
class Solution {
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        if(list1 == null) return list2;
        else if(list2 == null) return list1;

        ListNode dummy = new ListNode(0);
        ListNode curr = dummy;

        while(list1 != null && list2 != null) {

            if(list1.val <= list2.val) {
                curr.next = list1;
                list1 = list1.next;
            }
            else {
                curr.next = list2;
                list2 = list2.next;
            }

            curr = curr.next;
        }
        curr.next  = list1 == null? list2:list1;
        return dummy.next;
    }
}
TIME: TODO -
SPACE: TODO -
___________________________________________________________________________________
___________________________________________________________________________________


________________________________String________________________________
______________________________________________________________________
--------------------------------------------------------------20: Valid Parentheses (Easy)
sol1 - --------------
class Solution {
    public boolean isValid(String s) {
       //push starting char onto stack, if not check stack for match

        Stack<Character> stack = new Stack<Character>();
        //foreach loop
        for(char c: s.toCharArray()) {
            //if starting char, push to stack
            if(c == '(' || c == '[' || c == '{') {
                stack.push(c);
            } else if(c == ')' && !stack.isEmpty() && stack.peek() == '(') {
                stack.pop();
            } else if(c == ']' && !stack.isEmpty() && stack.peek() == '[') {
                stack.pop();
            } else if(c == '}' && !stack.isEmpty() && stack.peek() == '{') {
                stack.pop();
            } else {
                return false;
            }
        }
        return stack.isEmpty();
    }
}
TIME: TODO
SPACE: TODO

sol1b - Leetcode solution --------------
public boolean isValid(String s) {
	Stack<Character> stack = new Stack<Character>();
	for (char c : s.toCharArray()) {
		if (c == '(')
			stack.push(')');
		else if (c == '{')
			stack.push('}');
		else if (c == '[')
			stack.push(']');
		else if (stack.isEmpty() || stack.pop() != c)
			return false;
	}
	return stack.isEmpty();
}
TIME: TODO
SPACE: TODO


-------------------------------------424: Longest Repeating Character Replacement (Medium)
sol1 - HashMap, Sliding Window --------------
class Solution {
    public int characterReplacement(String s, int k) {
        char[] arr = s.toCharArray();
        int left = 0, right = 0, n = arr.length;

        //define table
        Map<Character, Integer> map = new HashMap<>();

        //define windowLen and mostFreq
        int maxLen = 0, mostFreq = 0;

        //find longest repeating character replacement
        while(right < n) {
            //Expand window
            map.put(arr[right], map.getOrDefault(arr[right], 0) + 1); //?
            mostFreq = Math.max(mostFreq, map.get(arr[right]));

            //Shrink the window if we need to replace more than k char
            if((right - left + 1) - mostFreq > k) {
                map.put(arr[left], map.get(arr[left]) - 1);
                left++;
            }
            maxLen = Math.max(maxLen, right - left + 1);
            right++;
        }
        return maxLen;
    }
}

TIME: O(n) - O(n*26) = O(n)
SPACE: TODO


_____________________________________________________________________
_____________________________________________________________________

________________________________TREES________________________________
_____________________________________________________________________
NOTE:Tree problems can be solved either recursively or iterativelly. Recursion makes more sense because it is way less code and is generally simplier.

--------------------------------------------------104: Maximum Depth of Binary Tree (Easy)
NOTE: Three approaches, recursive DFS, iterative DFS or BFS. DFS is more common and makes more sense for this problem but BFS
      can be used. It requires use of a queue or a stack.

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */

sol1a - DFS recursive--------------
class Solution {
    public int maxDepth(TreeNode root) {
        //base case
        if(root == null) {
            return 0;
        }

        int left = maxDepth(root.left);
        int right = maxDepth(root.right);
        return Math.max(left, right) + 1;
    }
}
TIME: O(n)
SPACE: O(n)

sol1b - DFS recursive simplified--------------
class Solution {
    public int maxDepth(TreeNode root) {
            if(root==null){
                return 0;
            }
            return Math.max(maxDepth(root.left),maxDepth(root.right)) + 1;
    }
}
TIME: O(n)
SPACE: O(n)

sol2 - BFS iterative-----------------
class Solution {
    public int maxDepth(TreeNode root) {
        if (root == null) return 0;

        int max = 1;

        Stack<TreeNode> nodes = new Stack<>();
        Stack<Integer> depths = new Stack<>();

        nodes.push(root);
        depths.push(1);

        while (!nodes.empty()) {
            TreeNode curr = nodes.pop();
            int depth = depths.pop();

            if (curr.left == null && curr.right == null) {
                max = Math.max(max, depth);
            }

            if (curr.right != null) {
                nodes.push(curr.right);
                depths.push(depth + 1);
            }
            if (curr.left != null) {
                nodes.push(curr.left);
                depths.push(depth + 1);
            }
        }

        return max;

    }
}
TIME: TODO
SPACE: TODO

---------------------------------------------------------------------100: Same Tree (Easy)
Note: always think about the base case when using recursion
sol1a - Recursion--------------
class Solution {
    public boolean isSameTree(TreeNode p, TreeNode q) {
        //base case(s)
        if(p == null && q == null) { // both null so same
            return true;
        } else if(p == null || q == null){ // only 1 null so diff
            return false;
        } else if(p.val != q.val) { // different root values
            return false;
        } else { //actual recursive calls
            return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);
        }
    }
}
TIME: O(n) - traversing the entire tree of both p and q so its 2n which is n
SPACE: O(logn) - best case / O(n) - worst case

sol1b - Recursion simplified--------------
public boolean isSameTree(TreeNode p, TreeNode q) {
    if(p == null && q == null) return true;
    if(p == null || q == null) return false;
    if(p.val == q.val)
        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);
    return false;
}
TIME: TODO
SPACE: TODO

------------------------------------------------------------226: Invert Binary Tree (Easy)
class Solution {
    public TreeNode invertTree(TreeNode root) {
        if(root == null) { //base case, invalid root
            return root;
        }

        //recursion
        TreeNode left = invertTree(root.left);
        TreeNode right = invertTree(root.right);

        //the swap
        root.right = left;
        root.left = right;

        return root;
    }
}
TIME: TODO
SPACE: TODO


-------------------------------------------572: Subtree of Another Tree (Easy *not really)
sol1a - Recursion--------------


TIME: TODO
SPACE: TODO



_____________________________________________________________________
_____________________________________________________________________





______________________________OTHER__________________________________
_____________________________________________________________________

-------------------------------------------------------509: Subtree of Another Tree (Easy)
sol1 - iterative--------------
public int fib(int n) {
        if(n <= 1) {return n;}

        int a = 0;
        int b = 0;

        while(n-- > 1) {
            int sum = a + b;
            a = b;
            b = sum;
        }
        return b;
    }
todo TIME: O(n) -
todo SPACE: O(1) -

sol2 - Recursion--------------
public int fib(int n) {
        if (n <= 1) {
            return n;
        }
        else {
            return fib(n-1) + fib(n-2);
        }
    }
todo TIME: O(2^n) - since T(n) = T(n-1) + T(n-2)is an exponential time
todo SPACE: O(n) - space for recursive function call stack

sol3 - DP (top down approach)--------------

int[] fib_cache = new int[31];

public int fib(int n) {
    if (n <= 1) {return n;}
    else if(fib_cache[n] != 0) {return fib_cache[n];}
    else {return fib_cache[n] = fib(n - 1) + fib(n - 2);}
}
todo TIME: O(n) -
todo SPACE: O(n) -

sol4 - DP (bottom up approach)--------------
public int fib(int n) {
    if (n <= 1) {return n;}

    int[] fib_cache = new int[n+1];
    fib_cache[1] = 1;

    for(int i = 2; i <= n; i++) {
        fib_cache[i] = fib_cache[i - 1] + fib_cache[i - 2];
    }
    return fib_cache[n];
}
todo TIME: O(n) -
todo SPACE: O(n) -



-------------------------------------------------------1137: N-th Tribonacci Number (easy)
sol1 - iterative--------------
public int tribonacci(int n) {
    if (n < 2) return n;
    int a = 0, b = 1, c = 1, d;
    while (n-- > 2) {
        d = a + b + c;
        a = b;
        b = c;
        c = d;
    }
    return c;
}
todo TIME: O(n) -
todo SPACE: O(1) -

sol2 - iterative--------------
public int tribonacci(int n) {
        int dp[] = {0, 1, 1};
        for (int i = 3; i <= n; ++i)
        dp[i % 3] = dp[0] + dp[1] + dp[2];
        return dp[n % 3];
}
todo TIME: O(n) -
todo SPACE: O(1) -
___________________________________________________________________________________
___________________________________________________________________________________




