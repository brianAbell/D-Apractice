_________________________________Expedia____________________________________
______________________________Last 6 months_________________________________

----------------------------------------------------------------1507: Reformat Date (easy)
sol1 - HashMap--------------
public String reformatDate(String date) {
    String[] months = new String[]{"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};
    Map<String, String> map = new HashMap<>();
    for (int i = 0; i < months.length; ++i) {
        map.put(months[i], (i + 1 < 10 ? "0" : "") + (i+1));
    }
    String[] parts = date.split(" ");
    String day = (parts[0].length() == 3 ? "0" : "") + parts[0].substring(0, parts[0].length() - 2);
    return parts[2] + "-" + map.get(parts[1]) + "-" + day;
}
todo TIME: O(n) -
todo SPACE: O(n^2) -

sol1 - Performance-wise switch approach--------------
 private String getMonth(String s) {
        switch(s) {
            case "Jan": return "01";
            case "Feb": return "02";
            case "Mar": return "03";
            case "Apr": return "04";
            case "May": return "05";
            case "Jun": return "06";
            case "Jul": return "07";
            case "Aug": return "08";
            case "Sep": return "09";
            case "Oct": return "10";
            case "Nov": return "11";
            default: return "12";
        }
    }

    public String reformatDate(String date) {
        String[] d = date.split(" ");
        return d[2] + "-" +
            getMonth(d[1]) + "-" +
            (d[0].length() == 3 ? "0" + d[0].substring(0, 1) : d[0].substring(0, 2));
    }
todo TIME: O(?) -
todo SPACE: O(?) -
------------------------------------------------------------697: Degree of an Array (easy)
sol1 - Left and Right Index--------------
public int findShortestSubArray(int[] nums) {
        Map<Integer, Integer> left = new HashMap(),
            right = new HashMap(), count = new HashMap();

        for (int i = 0; i < nums.length; i++) {
            int x = nums[i];
            if (left.get(x) == null) left.put(x, i);
            right.put(x, i);
            count.put(x, count.getOrDefault(x, 0) + 1);
        }

        int ans = nums.length;
        int degree = Collections.max(count.values());
        for (int x: count.keySet()) {
            if (count.get(x) == degree) {
                ans = Math.min(ans, right.get(x) - left.get(x) + 1);
            }
        }
        return ans;
}
todo TIME: O(n) - Every loop is through O(n) items with O(1) work inside the for-block
todo SPACE: O(n) - the space used by left, right, and count

-----------------------------------------------121. Best Time to Buy and Sell Stock (Easy)

sol1 - Brute Force--------------
public class Solution {
    public int maxProfit(int prices[]) {
        int max = 0;
        for (int i = 0; i < prices.length - 1; i++) {
            for (int j = i + 1; j < prices.length; j++) {
                int profit = prices[j] - prices[i];
                if (profit > max)
                    max = profit;
            }
        }
        return max;
    }
}
TIME: O(n^2) - nested for loops so nested iterations present
SPACE: O(1) - only a few variables used to store data

sol3 - Dynamic Programming--------------
public class Solution {
    public int maxProfit(int[] prices) {
        int max = 0;
        int min = Integer.MAX_VALUE;

        for(int i = 0; i < prices.length; i++) {
            if(prices[i] < min) {
                min = prices[i];
            }
            else if(prices[i] - min > max) {
                max = prices[i] - min;
            }
        }
        return max;
    }
}
TIME: O(n) - Single iteration through, utilize max min data
SPACE: O(1) - only creating a couple variables for storing data.

sol3 - Two pointer efficient--------------
public class Solution {
    public int maxProfit(int[] prices) {
        int max = 0;
        if(prices.length == 0){
            return max;
        }
        int min=prices[0];
        for(int i = 1; i < prices.length; i++){
            if(prices[i] > min){
                if(max < (prices[i] - min)){
                    max=prices[i] - min;
                }
            }
            else{ min = prices[i]; }
        }
        return max;
    }
}
todo TIME: O(?) -
todo SPACE: O(?) -

--------------------------------------------------------------724: Find Pivot Index (easy)
sol1 - Prefix Sum--------------
public int pivotIndex(int[] nums) {
        int sum = 0, leftsum = 0;
        for (int x: nums) sum += x;
        for (int i = 0; i < nums.length; ++i) {
            if (leftsum == sum - leftsum - nums[i]) return i;
            leftsum += nums[i];
        }
        return -1;
}
todo TIME: O(n) - n is length of nums
todo SPACE: O(1) - space used by leftsum and S

----------------------------------------------------------------70: Climbing Stairs (Easy)
sol1 - Brute Force--------------


TIME: TODO
SPACE: TODO


sol2 - The Fastest time complexity, not using array----------------
public int climbStairs(int n) {
    //base cases
    if(n == 1) return 1;
    if(n == 2) return 2;

    //rest
    int a = 1;
    int b = 2;
    int ways = 0;

    for(int i = 2; i < n; i++) {
        ways = a + b;
        a = b;
        b = ways;
    }
    return ways;
}
todo TIME: O(n)
todo SPACE: O(1)

sol3 - The Fastest time complexity, using array---------
public int climbStairs(int n) {
        int[] dp = new int[n+1];
        dp[0]=1;
        dp[1]=1;
        for(int i = 2; i <= n; i++) {
            dp[i] = dp[i-1] + dp[i-2];
        }
        return dp[n];
}
TIME: O(n)
SPACE: O(n)

-------------------------------------------------------------------------1. Two Sum (Easy)

sol1 - Brute Force 2 pointer solution--------------
class Solution {
    public int[] twoSum(int[] nums, int target) {
        int[] ans = new int[2];
        for(int i = 0; i < nums.length; i++) {
            int curr1 = nums[i];
            for(int j = i+1; j < nums.length; j++) {
                int curr2 = nums[j];
                if(curr1 + curr2 == target) {

                    ans[0] = i;
                    ans[1] = j;
                    return ans;
                }
            }
        }
        return ans;
    }
}
TIME: O(n^2)
SPACE: TODO

sol2 - hashmap--------------
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> visitedNumbers = new HashMap<>();
        for(int i = 0; i < nums.length; i++) {
            // x + y = target
            int delta = target - nums[i];
            if(visitedNumbers.containsKey(delta)) {
                return new int[] {i, visitedNumbers.get(delta)};
            }
            visitedNumbers.put(nums[i], i);
        }
        return new int[] {-1, -1};
    }
}
TIME: O(n)
SPACE: TODO

--------------------------------------------------------------20: Valid Parentheses (Easy)
sol1 - --------------
class Solution {
    public boolean isValid(String s) {
       //push starting char onto stack, if not check stack for match

        Stack<Character> stack = new Stack<Character>();
        //foreach loop
        for(char c: s.toCharArray()) {
            //if starting char, push to stack
            if(c == '(' || c == '[' || c == '{') {
                stack.push(c);
            } else if(c == ')' && !stack.isEmpty() && stack.peek() == '(') {
                stack.pop();
            } else if(c == ']' && !stack.isEmpty() && stack.peek() == '[') {
                stack.pop();
            } else if(c == '}' && !stack.isEmpty() && stack.peek() == '{') {
                stack.pop();
            } else {
                return false;
            }
        }
        return stack.isEmpty();
    }
}
TIME: TODO
SPACE: TODO

sol1b - Leetcode solution --------------
public boolean isValid(String s) {
	Stack<Character> stack = new Stack<Character>();
	for (char c : s.toCharArray()) {
		if (c == '(')
			stack.push(')');
		else if (c == '{')
			stack.push('}');
		else if (c == '[')
			stack.push(']');
		else if (stack.isEmpty() || stack.pop() != c)
			return false;
	}
	return stack.isEmpty();
}
TIME: TODO
SPACE: TODO

--------------------------------------------------------1492: The kth Factor of n (medium)

--------------------------------------122: The Best Time to Buy and Sell Stock II (medium)

---------------------------1481: Least Number of Unique Integers after K Removals (medium)

-----------------------------------------------438: Find All Anagrams in a String (medium)

----------------------------------------------------------443: String Compression (medium)

--------------------------------------------------------------56: Merge Intervals (medium)

-------------------------------------------------------560: Subarray Sum Equals K (medium)

----------------------------------------------------316: Remove Duplicate Letters (medium)

-------------------------------------------------------1197: Minimum Knight Moves (medium)

-----------------------------------------------33: Search in Rotated Sorted Array (medium)

---------1465: Maximum Area of a Piece of Cake After Horizontal and Vertical Cuts (medium)

----------------------------------------------1487: N-th Making File Names Unique (medium)
sol1 - HashMap--------------
public String[] getFolderNames(String[] names) {
        //Store name and all suffix into the HashSet
        HashMap<String,HashSet<Integer>> map = new HashMap<>();
        //nextSmallestSuffixMap: To make sure O(n) time complexity, store the start of suffix in another map
        HashMap<String,Integer> nextSmallestSuffixMap = new HashMap<>();

        List<String> list = new ArrayList<>();
        for(String name: names){
            if(map.containsKey(name)){
                HashSet<Integer> tempSet = map.get(name);
                int index = nextSmallestSuffixMap.get(name);//do not need to start with 0 to scan
                while(tempSet.contains(index)){
                    index++;
                }
                //Check whether parentName(index) occurs in the map
                //if so, update nextSmallestSuffixMap to make sure next time it won't be scanned
                //and record this into the map
                while(map.containsKey(name+'('+index+')')){
                    index++;
                }
                //update nextSmallestSuffixMap
                nextSmallestSuffixMap.put(name,index+1);
                //update name related HashSet with smallestIndex
                tempSet.add(index);
                //update newName with index 0
                String s = name+'('+index+')';
                tempSet = new HashSet<>();
                tempSet.add(0);
                map.put(s,tempSet);
                //update theNextSmallestSuffix with index 1
                nextSmallestSuffixMap.put(s,1);
                //add fileName into list
                list.add(s);
            }else{
                list.add(name);
                //update theNextSmallestSuffix with index 1
                nextSmallestSuffixMap.put(name,1);
                //update name related HashSet with smallestIndex
                HashSet<Integer> tempSet = new HashSet<>();
                tempSet.add(0);
                map.put(name,tempSet);
            }
        }
        String[] arr = new String[list.size()];
        for(int i = 0;i<list.size();i++){
            arr[i] = list.get(i);
        }
        return arr;
}
todo TIME: O(n) -
todo SPACE: O(n^2) -

------------------------------------------------------------296: Best Meeting Point (hard)

------------------------------------------------------------42: Trapping Rain Water (hard)

-------------------------------------------------------------------127: Word Ladder (hard)


_________________________________ALL TIME____________________________________
______________________________other problems_________________________________