$$BLIND 75$$

________________________________ARRAYS________________________________
______________________________________________________________________

--------------1. Two Sum (Easy)--------------

sol1 - Brute Force 2 pointer solution--------------
class Solution {
    public int[] twoSum(int[] nums, int target) {
        int[] ans = new int[2];
        for(int i = 0; i < nums.length; i++) {
            int curr1 = nums[i];
            for(int j = i+1; j < nums.length; j++) {
                int curr2 = nums[j];
                if(curr1 + curr2 == target) {

                    ans[0] = i;
                    ans[1] = j;
                    return ans;
                }
            }
        }
        return ans;
    }
}
TIME: O(n^2)
SPACE: TODO

sol2 - hashmap--------------
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> visitedNumbers = new HashMap<>();
        for(int i = 0; i < nums.length; i++) {
            // x + y = target
            int delta = target - nums[i];
            if(visitedNumbers.containsKey(delta)) {
                return new int[] {i, visitedNumbers.get(delta)};
            }
            visitedNumbers.put(nums[i], i);
        }
        return new int[] {-1, -1};
    }
}
TIME: O(n)
SPACE: TODO

--------------121. Best Time to Buy and Sell Stock (Easy)--------------

sol1 - Brute Force--------------
public class Solution {
    public int maxProfit(int prices[]) {
        int max = 0;
        for (int i = 0; i < prices.length - 1; i++) {
            for (int j = i + 1; j < prices.length; j++) {
                int profit = prices[j] - prices[i];
                if (profit > max)
                    max = profit;
            }
        }
        return max;
    }
}
TIME: O(n^2)
SPACE: TODO

sol3 - Dynamic Programming--------------
public class Solution {
    public int maxProfit(int[] prices) {
        int max = 0;
        int min = Integer.MAX_VALUE;

        for(int i = 0; i < prices.length; i++) {
            if(prices[i] < min) {
                min = prices[i];
            }
            else if(prices[i] - min > max) {
                max = prices[i] - min;
            }
        }
        return max;
    }
}
TIME: TODO
SPACE: TODO

sol3 - Two pointer efficient--------------
public class Solution {
    public int maxProfit(int[] prices) {
        int max = 0;
        if(prices.length == 0){
            return max;
        }
        int min=prices[0];
        for(int i = 1; i < prices.length; i++){
            if(prices[i] > min){
                if(max < (prices[i] - min)){
                    max=prices[i] - min;
                }
            }
            else{ min = prices[i]; }
        }
        return max;
    }
}
TIME: TODO
SPACE: TODO

--------------217. Contains Duplicate (Easy)--------------

sol1 - Brute Force - linear search took to long though--------------
class Solution {
    public boolean containsDuplicate(int[] nums) {
        int count = 0;

        for(int i = 0; i < nums.length - 1; i++) {
             for(int j = i + 1; j < nums.length; j++) {
                 if(nums[i] == nums[j]) {
                     return true;
                 }
             }
        }
        return false;
    }
}
TIME: O(n^2)
SPACE: O(1)

sol2 - Slightly better--------------
class Solution {
    Arrays.sort(nums);
    for(int i = 1; i < nums.length; i++) {
        if(nums[i] == nums[i - 1]) {
            return true;
        }
    }
    return false;
}
TIME: O(nlogn)
SPACE: O(1)

sol3 - Hashsets--------------
class Solution {
    public  boolean containsDuplicate(int[] nums) {
		 Set<Integer> set = new HashSet<Integer>();
		 for(int i : nums)
			 if(!set.add(i))// if there is same
				 return true;
		 return false;
	 }
}
TIME: O(n)
SPACE: O(n)

--------------53: Maximum Subarray (Easy)--------------
TODO sol1 - Brute force--------------

for(i=0...n-1)
    for(j=i...j)
        for(k=i...j)
            compute sum

TIME: O(n^2)
SPACE: TODO

TODO sol3 - Passable solution--------------
for(i=0...n-1)
    for(j=i...n-1)
        currsum + num[j]
TIME: O(n^2)
SPACE: TODO

sol3 - improved-------------- do we actually have to compute EVERY sub array?
class Solution {
    public int maxSubArray(int[] nums) {
        int max = Integer.MIN_VALUE;
        int sum = 0;

        for(int i = 0; i < nums.length; i++) {
            sum = sum + nums[i]; // 0 = 0 + 4
            max = Math.max(sum, max);

            if(sum < 0) {sum = 0;}
        }
        return max;
    }
}
TIME: TODO
SPACE: TODO
--------------238: Product of Array Except Self (Medium)--------------

sol1 - Passable solution--------------
class Solution {
    public int[] productExceptSelf(int[] nums) {
        //validity checker
        if(nums == null || nums.length == 0) return new int[0];

        int[] result = new int[nums.length];

        //running product
        int rp = 1;

        //left pass
        for(int i = 0; i < nums.length; i++) {
            result[i] = rp;
            rp = rp * nums[i];
        }

        //right pass
        rp = 1;

        for(int i = nums.length - 1; i >= 0; i--) {
            result[i] = result[i] * rp;
            rp = rp * nums[i];
        }

        return result;
    }
}
TIME: O(n) - We traverse through the array twice(left,right) which results in O(2n)==O(n)
SPACE: O(1) - Result array is only array used for calculations and is the only array returned.

TODO sol2 - Faster solution--------------




______________________________________________________________________
______________________________________________________________________


________________________________BINARY________________________________
______________________________________________________________________
--------------371. Sum of Two Integers (Medium)--------------
TODO

--------------191. Number of 1 Bits (Easy)--------------
sol1 - Brute Force--------------


TIME: TODO
SPACE: TODO



______________________________________________________________________
______________________________________________________________________

________________________________DYNAMIC PROGRAMMING________________________________
___________________________________________________________________________________

--------------70: Climbing Stairs (Easy)--------------
sol1 - Brute Force--------------


TIME: TODO
SPACE: TODO


sol2 - The Fastest time complexity, not using array----------------
public int climbStairs(int n) {
    //base cases
    if(n == 1) return 1;
    if(n == 2) return 2;

    //rest
    int a = 1;
    int b = 2;
    int ways = 0;

    for(int i = 2; i < n; i++) {
        ways = a + b;
        a = b;
        b = ways;
    }
    return ways;
}
TIME: TODO
SPACE: TODO

sol3 - The Fastest time complexity, using array---------
public int climbStairs(int n) {
        int[] dp = new int[n+1];
        dp[0]=1;
        dp[1]=1;
        for(int i = 2; i <= n; i++) {
            dp[i] = dp[i-1] + dp[i-2];
        }
        return dp[n];
}
TIME: TODO
SPACE: TODO

___________________________________________________________________________________
___________________________________________________________________________________

________________________________Graph________________________________
_____________________________________________________________________

TODO

___________________________________________________________________________________
___________________________________________________________________________________

________________________________Interval________________________________
________________________________________________________________________

TODO

___________________________________________________________________________________
___________________________________________________________________________________

________________________________Linked List________________________________
___________________________________________________________________________

--------------206: Reverse Linked List (Easy)--------------
sol1 - Brute Force, iterative--------------
NOTE: singly linked lists prevent traversing backwards so our solution requires us to keep track of the prev node.

public ListNode reverseList(ListNode head) {
        ListNode prev = null; //init pointer
        ListNode next = null; //init pointer

        while(head != null) {
            next = head.next; //save next
            head.next = prev; //reverse
            prev = head; //advance prev & head
            head = next; //advance prev & head
        }
        return prev; //new head at end
}
TIME: O(n)
SPACE: O(1) / O(n)

sol2 - Recursive--------------

// 1 -> 2 -> 3
// 3 -> 2 -> 1

public ListNode reverseList(ListNode head) {
    return reverseListInt(head, null);
}

public ListNode reverseListInt(ListNode head, ListNode newHead) {
    if(head == null) {return newHead;}
    ListNode next = head.next;
    head.next = newHead;
    return reverseListInt(next, head);
}
TIME: O(n)
SPACE: O(n)

--------------141: Linked List Cycle (Easy)--------------
sol1 - Brute Force, iterative--------------

TIME: TODO
SPACE: TODO

sol2 - Recursive--------------

TIME: TODO
SPACE: TODO
___________________________________________________________________________________
___________________________________________________________________________________


________________________________String________________________________
______________________________________________________________________
--------------20: Valid Parentheses (Easy)--------------
sol1 - --------------
class Solution {
    public boolean isValid(String s) {
       //push starting char onto stack, if not check stack for match

        Stack<Character> stack = new Stack<Character>();
        //foreach loop
        for(char c: s.toCharArray()) {
            //if starting char, push to stack
            if(c == '(' || c == '[' || c == '{') {
                stack.push(c);
            } else if(c == ')' && !stack.isEmpty() && stack.peek() == '(') {
                stack.pop();
            } else if(c == ']' && !stack.isEmpty() && stack.peek() == '[') {
                stack.pop();
            } else if(c == '}' && !stack.isEmpty() && stack.peek() == '{') {
                stack.pop();
            } else {
                return false;
            }
        }
        return stack.isEmpty();
    }
}
TIME: TODO
SPACE: TODO

sol1b - Leetcode solution --------------
public boolean isValid(String s) {
	Stack<Character> stack = new Stack<Character>();
	for (char c : s.toCharArray()) {
		if (c == '(')
			stack.push(')');
		else if (c == '{')
			stack.push('}');
		else if (c == '[')
			stack.push(']');
		else if (stack.isEmpty() || stack.pop() != c)
			return false;
	}
	return stack.isEmpty();
}
TIME: TODO
SPACE: TODO


--------------424: Longest Repeating Character Replacement (Medium)--------------
sol1 - HashMap, Sliding Window --------------
class Solution {
    public int characterReplacement(String s, int k) {
        char[] arr = s.toCharArray();
        int left = 0, right = 0, n = arr.length;

        //define table
        Map<Character, Integer> map = new HashMap<>();

        //define windowLen and mostFreq
        int maxLen = 0, mostFreq = 0;

        //find longest repeating character replacement
        while(right < n) {
            //Expand window
            map.put(arr[right], map.getOrDefault(arr[right], 0) + 1); //?
            mostFreq = Math.max(mostFreq, map.get(arr[right]));

            //Shrink the window if we need to replace more than k char
            if((right - left + 1) - mostFreq > k) {
                map.put(arr[left], map.get(arr[left]) - 1);
                left++;
            }
            maxLen = Math.max(maxLen, right - left + 1);
            right++;
        }
        return maxLen;
    }
}

TIME: O(n) - O(n*26) = O(n)
SPACE: TODO


_____________________________________________________________________
_____________________________________________________________________

________________________________TREES________________________________
_____________________________________________________________________
NOTE:Tree problems can be solved either recursively or iterativelly. Recursion makes more sense because it is way less code and is generally simplier.

--------------104: Maximum Depth of Binary Tree (Easy)--------------
NOTE: Three approaches, recursive DFS, iterative DFS or BFS. DFS is more common and makes more sense for this problem but BFS
      can be used. It requires use of a queue or a stack.

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */

sol1a - DFS recursive--------------
class Solution {
    public int maxDepth(TreeNode root) {
        //base case
        if(root == null) {
            return 0;
        }

        int left = maxDepth(root.left);
        int right = maxDepth(root.right);
        return Math.max(left, right) + 1;
    }
}
TIME: O(n)
SPACE: O(n)

sol1b - DFS recursive simplified--------------
class Solution {
    public int maxDepth(TreeNode root) {
            if(root==null){
                return 0;
            }
            return Math.max(maxDepth(root.left),maxDepth(root.right)) + 1;
    }
}
TIME: O(n)
SPACE: O(n)

sol2 - BFS iterative-----------------
class Solution {
    public int maxDepth(TreeNode root) {
        if (root == null) return 0;

        int max = 1;

        Stack<TreeNode> nodes = new Stack<>();
        Stack<Integer> depths = new Stack<>();

        nodes.push(root);
        depths.push(1);

        while (!nodes.empty()) {
            TreeNode curr = nodes.pop();
            int depth = depths.pop();

            if (curr.left == null && curr.right == null) {
                max = Math.max(max, depth);
            }

            if (curr.right != null) {
                nodes.push(curr.right);
                depths.push(depth + 1);
            }
            if (curr.left != null) {
                nodes.push(curr.left);
                depths.push(depth + 1);
            }
        }

        return max;

    }
}
TIME: TODO
SPACE: TODO

--------------100: Same Tree (Easy)--------------
Note: always think about the base case when using recursion
sol1a - Recursion--------------
class Solution {
    public boolean isSameTree(TreeNode p, TreeNode q) {
        //base case(s)
        if(p == null && q == null) { // both null so same
            return true;
        } else if(p == null || q == null){ // only 1 null so diff
            return false;
        } else if(p.val != q.val) { // different root values
            return false;
        } else { //actual recursive calls
            return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);
        }
    }
}
TIME: O(n) - traversing the entire tree of both p and q so its 2n which is n
SPACE: O(logn) - best case / O(n) - worst case

sol1b - Recursion simplified--------------
public boolean isSameTree(TreeNode p, TreeNode q) {
    if(p == null && q == null) return true;
    if(p == null || q == null) return false;
    if(p.val == q.val)
        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);
    return false;
}
TIME: TODO
SPACE: TODO

--------------226: Invert Binary Tree (Easy)--------------
sol1a - Recursion--------------
class Solution {
    public TreeNode invertTree(TreeNode root) {
        if(root == null) { //base case, invalid root
            return root;
        }

        //recursion
        TreeNode left = invertTree(root.left);
        TreeNode right = invertTree(root.right);

        //the swap
        root.right = left;
        root.left = right;

        return root;
    }
}
TIME: TODO
SPACE: TODO


--------------572: Subtree of Another Tree (Easy *not really)--------------
sol1a - Recursion--------------


TIME: TODO
SPACE: TODO



_____________________________________________________________________
_____________________________________________________________________
