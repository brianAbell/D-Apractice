$$BLIND 75$$

________________________________ARRAYS________________________________
______________________________________________________________________

-------------------------------------------------------------------------1. Two Sum (Easy)

sol1 - Brute Force 2 pointer solution--------------
class Solution {
    public int[] twoSum(int[] nums, int target) {
        int[] ans = new int[2];
        for(int i = 0; i < nums.length; i++) {
            int curr1 = nums[i];
            for(int j = i+1; j < nums.length; j++) {
                int curr2 = nums[j];
                if(curr1 + curr2 == target) {

                    ans[0] = i;
                    ans[1] = j;
                    return ans;
                }
            }
        }
        return ans;
    }
}
TIME: O(n^2)
SPACE: TODO

sol2 - hashmap--------------
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> visitedNumbers = new HashMap<>();
        for(int i = 0; i < nums.length; i++) {
            // x + y = target
            int delta = target - nums[i];
            if(visitedNumbers.containsKey(delta)) {
                return new int[] {i, visitedNumbers.get(delta)};
            }
            visitedNumbers.put(nums[i], i);
        }
        return new int[] {-1, -1};
    }
}
TIME: O(n)
SPACE: TODO

-----------------------------------------------121. Best Time to Buy and Sell Stock (Easy)

sol1 - Brute Force--------------
public class Solution {
    public int maxProfit(int prices[]) {
        int max = 0;
        for (int i = 0; i < prices.length - 1; i++) {
            for (int j = i + 1; j < prices.length; j++) {
                int profit = prices[j] - prices[i];
                if (profit > max)
                    max = profit;
            }
        }
        return max;
    }
}
TIME: O(n^2)
SPACE: TODO

sol3 - Dynamic Programming--------------
public class Solution {
    public int maxProfit(int[] prices) {
        int max = 0;
        int min = Integer.MAX_VALUE;

        for(int i = 0; i < prices.length; i++) {
            if(prices[i] < min) {
                min = prices[i];
            }
            else if(prices[i] - min > max) {
                max = prices[i] - min;
            }
        }
        return max;
    }
}
TIME: TODO
SPACE: TODO

sol3 - Two pointer efficient--------------
public class Solution {
    public int maxProfit(int[] prices) {
        int max = 0;
        if(prices.length == 0){
            return max;
        }
        int min=prices[0];
        for(int i = 1; i < prices.length; i++){
            if(prices[i] > min){
                if(max < (prices[i] - min)){
                    max=prices[i] - min;
                }
            }
            else{ min = prices[i]; }
        }
        return max;
    }
}
TIME: TODO
SPACE: TODO

------------------------------------------------------------217. Contains Duplicate (Easy)

sol1 - Brute Force - linear search took to long though--------------
class Solution {
    public boolean containsDuplicate(int[] nums) {
        int count = 0;

        for(int i = 0; i < nums.length - 1; i++) {
             for(int j = i + 1; j < nums.length; j++) {
                 if(nums[i] == nums[j]) {
                     return true;
                 }
             }
        }
        return false;
    }
}
TIME: O(n^2)
SPACE: O(1)

sol2 - Slightly better--------------
class Solution {
    Arrays.sort(nums);
    for(int i = 1; i < nums.length; i++) {
        if(nums[i] == nums[i - 1]) {
            return true;
        }
    }
    return false;
}
TIME: O(nlogn)
SPACE: O(1)

sol3 - Hashsets--------------
class Solution {
    public  boolean containsDuplicate(int[] nums) {
		 Set<Integer> set = new HashSet<Integer>();
		 for(int i : nums)
			 if(!set.add(i))// if there is same
				 return true;
		 return false;
	 }
}
TIME: O(n)
SPACE: O(n)

---------------------------------------------------------------53: Maximum Subarray (Easy)
TODO sol1 - Brute force--------------

for(i=0...n-1)
    for(j=i...j)
        for(k=i...j)
            compute sum

TIME: O(n^2)
SPACE: TODO

TODO sol3 - Passable solution--------------
for(i=0...n-1)
    for(j=i...n-1)
        currsum + num[j]
TIME: O(n^2)
SPACE: TODO

sol3 - improved-------------- do we actually have to compute EVERY sub array?
class Solution {
    public int maxSubArray(int[] nums) {
        int max = Integer.MIN_VALUE;
        int sum = 0;

        for(int i = 0; i < nums.length; i++) {
            sum = sum + nums[i]; // 0 = 0 + 4
            max = Math.max(sum, max);

            if(sum < 0) {sum = 0;}
        }
        return max;
    }
}
TIME: TODO
SPACE: TODO


----------------------------------------------------------------268: Missing Number (Easy)
sol1 - Linear Time solution VERY BAD--------------
class Solution {
    public int missingNumber(int[] nums) {
        //1. create set then fill it with the values
        HashSet<Integer> set = new HashSet<Integer>();
        for(int i: nums) {
            set.add(i);
        }

        //2. iterate through and compare input vals to set vals. return missing num if found
        for(int i = 0; i < nums.length; i++) {
            if(!set.contains(i)) {
                return i;
            }
        }
        //else return the next num in line
        return nums.length;
    }
}
TIME: O(n)
SPACE: O(n)

sol1 - Gausses rule, best solution--------------
class Solution {
    public int missingNumber(int[] nums) {
        int sum = 0;
        for(int i: nums) {
            sum += i;
        }

        int n = nums.length+1;
        return (n*(n-1)/2) - sum;
    }
}
TIME: O(1)
SPACE: O(1)


--------------------------------------448: Find All Numbers Disappeared in an Array (Easy)
sol1 - Using HashSet--------------
public List<Integer> findDisappearedNumbers(int[] nums) {

    //create list for results
    List<Integer> result = new ArrayList<Integer>();
    //create hashSet for reference
    HashSet<Integer> set = new HashSet<Integer>();
        //add all values to hashSet
        for(int num: nums) {
            set.add(num);
        }

        //iterate through and if value not in set, add to missing number result list
        for(int i = 1; i <= nums.length; i++) {
            if(!set.contains(i)) {
                result.add(i);
            }
        }

        return result;
    }
TODO TIME: O(n) - traversal of entire array once
TODO SPACE: O(n) - all numbers stored in array and hashtable

sol2 - use input array to not use extra memory--------------
public List<Integer> findDisappearedNumbers(int[] nums) {
        //create index for checking
        int index;
        //iterate through the array
        for(int i = 0; i < nums.length; i++) {
            //update index
            index = Math.abs(nums[i]) - 1;
            //
            if(nums[index] > 0) {
                nums[index] = nums[index] * -1;
            }
        }

        List<Integer> result = new ArrayList<Integer>();

        for(int i = 0; i < nums.length; i++) {
            //
            if(nums[i] > 0) {
                result.add(i+1);
            }
        }
        return result;
    }
TODO TIME: O(n) -
TODO SPACE: O(1) - No extra space used as we reuse input structure

-----------------------------------------------------------------136: Single Number (Easy)
sol1 - using HashSet--------------
public int singleNumber(int[] nums) {
        Set<Integer> set = new HashSet<Integer>();
        // loop through input array
        for(int i = 0; i < nums.length; i++) {
            //if set contains the arrays current index value
            if(set.contains(nums[i])) {
                //remove from the set
                set.remove(nums[i]);
            }
            //add to the set
            else {
                set.add(nums[i]);
            }
        }
        //loop through input array
        for(int i = 0; i< nums.length; i++) {
            //if set contains the arrays current index value
            if(set.contains(nums[i])) {
                // return that index value
                return nums[i];
            }
        }
        return -1;
    }
TODO TIME: O(n^2) -
TODO SPACE: O(n) -

sol2 - Sorting algorithm--------------
TODO TIME: O(nlogn) -
TODO SPACE: O(1) -


------------------------------------------------238: Product of Array Except Self (Medium)

sol1 - Passable solution--------------
class Solution {
    public int[] productExceptSelf(int[] nums) {
        //validity checker
        if(nums == null || nums.length == 0) return new int[0];

        int[] result = new int[nums.length];

        //running product
        int rp = 1;

        //left pass
        for(int i = 0; i < nums.length; i++) {
            result[i] = rp;
            rp = rp * nums[i];
        }

        //right pass
        rp = 1;

        for(int i = nums.length - 1; i >= 0; i--) {
            result[i] = result[i] * rp;
            rp = rp * nums[i];
        }

        return result;
    }
}
TIME: O(n) - We traverse through the array twice(left,right) which results in O(2n)==O(n)
SPACE: O(1) - Result array is only array used for calculations and is the only array returned.

TODO sol2 - Faster solution--------------




______________________________________________________________________
______________________________________________________________________


________________________________BINARY________________________________
______________________________________________________________________
---------------------------------------------------------371. Sum of Two Integers (Medium)
TODO

--------------191. Number of 1 Bits (Easy)--------------
sol1 - Brute Force--------------


TIME: TODO
SPACE: TODO



______________________________________________________________________
______________________________________________________________________

________________________________DYNAMIC PROGRAMMING________________________________
___________________________________________________________________________________

----------------------------------------------------------------70: Climbing Stairs (Easy)
sol1 - Brute Force--------------


TIME: TODO
SPACE: TODO


sol2 - The Fastest time complexity, not using array----------------
public int climbStairs(int n) {
    //base cases
    if(n == 1) return 1;
    if(n == 2) return 2;

    //rest
    int a = 1;
    int b = 2;
    int ways = 0;

    for(int i = 2; i < n; i++) {
        ways = a + b;
        a = b;
        b = ways;
    }
    return ways;
}
TIME: TODO
SPACE: TODO

sol3 - The Fastest time complexity, using array---------
public int climbStairs(int n) {
        int[] dp = new int[n+1];
        dp[0]=1;
        dp[1]=1;
        for(int i = 2; i <= n; i++) {
            dp[i] = dp[i-1] + dp[i-2];
        }
        return dp[n];
}
TIME: TODO
SPACE: TODO



----------------------------------------------------------------198: House Robber (Medium)
sol1 - DP--------------
 class Solution {
     public int rob(int[] nums) {
         // case 1: size of 0 or null
         if(nums == null || nums.length == 0) {
             return 0;
         }

         //case 2: size of 1
         if(nums.length == 1) {
             return nums[0];
         }

         //case 3: size of 2
         if(nums.length == 2) {
             return Math.max(nums[0], nums[1]);
         }

         //case 4: larger than 2
         int[] dp = new int[nums.length];
         dp[0] = nums[0];
         dp[1] = Math.max(nums[0], nums[1]);
         for(int i = 2; i < dp.length; i++) {
             dp[i] = Math.max(nums[i] + dp[i - 2], dp[i - 1]);
         }

         return dp[nums.length - 1];
     }
 }
TIME: TODO
SPACE: TODO

sol2 - TBD--------------

TIME: TODO
SPACE: TODO


___________________________________________________________________________________
___________________________________________________________________________________

________________________________Graph________________________________
_____________________________________________________________________

TODO

___________________________________________________________________________________
___________________________________________________________________________________

________________________________Interval________________________________
________________________________________________________________________

TODO

___________________________________________________________________________________
___________________________________________________________________________________

________________________________Linked List________________________________
___________________________________________________________________________

-----------------------------------------------------------206: Reverse Linked List (Easy)
sol1 - Brute Force, iterative--------------
NOTE: singly linked lists prevent traversing backwards so our solution requires us to keep track of the prev node.

public ListNode reverseList(ListNode head) {
        ListNode prev = null; //init pointer
        ListNode next = null; //init pointer

        while(head != null) {
            next = head.next; //save next
            head.next = prev; //reverse
            prev = head; //advance prev & head
            head = next; //advance prev & head
        }
        return prev; //new head at end
}
TIME: O(n)
SPACE: O(1) / O(n)

sol2 - Recursive--------------

// 1 -> 2 -> 3
// 3 -> 2 -> 1

public ListNode reverseList(ListNode head) {
    return reverseListInt(head, null);
}

public ListNode reverseListInt(ListNode head, ListNode newHead) {
    if(head == null) {return newHead;}
    ListNode next = head.next;
    head.next = newHead;
    return reverseListInt(next, head);
}
TIME: O(n)
SPACE: O(n)

-------------------------------------------------------------141: Linked List Cycle (Easy)
sol1 - HashMap -------------- TODO

TIME: TODO -
SPACE: TODO -

sol2 - Floyd's Tortoise & Hare Algorithm--------------
public class Solution {
    public boolean hasCycle(ListNode head) {
        //if invalid list, then no cycle
        if(head == null) return false;

        //create two list nodes which will act as slow and fast pointers respectively
        ListNode s = head;
        ListNode f = head;

        //while there are still valid nodes ahead for both s and f to move to...
        while(f.next != null && f.next.next != null) {

            //we will simply move the pointers to their next nodes
            s = s.next;
            f = f.next.next;

            //if our pointers meet at a similar node, then there is a cycle
            if(s == f) return true;
        }
        //if not, there is no cycle
        return false;
    }
}

TIME: O(n) -
SPACE: O(1) -


---------------------------------------------------------21: Merge Two Sorted Lists (Easy)
sol1 - iterative --------------
class Solution {
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        //creating our new list below
        ListNode dummy = new ListNode(-1);
        ListNode head = dummy;

        while(list1 != null && list2 != null) {
            //if value in list1 is less than value in list2
            if(list1.val < list2.val) {
                //we assign the next element in dummy list to list1s node
                dummy.next = list1;
                //we then move to the next list1 node
                list1 = list1.next;
            } else {
                //else we assign the next element in dummy list to list2s node
                dummy.next = list2;
                //we then move to the next list2 node
                list2 = list2.next;
            }
            dummy = dummy.next;
        }

        //if there are remaining elements in list 1, we append them to end
        if(list1 != null) {
            dummy.next = list1;
        } else {
            dummy.next = list2;
        }

        return head.next;
    }
}

TIME: O(n) - where n is the size of the smaller list... we only have n iterations in our while loop,
            then simply append the remaining list to our sorted list
SPACE: O(1) - we are only declaring a couple variables and are reusing the memory in all the list nodes

sol2 - TBD -------------- TODO

TIME: TODO -
SPACE: TODO -



sol3 - iterative leetcode comment-------------------
class Solution {
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        if(list1 == null) return list2;
        else if(list2 == null) return list1;

        ListNode dummy = new ListNode(0);
        ListNode curr = dummy;

        while(list1 != null && list2 != null) {

            if(list1.val <= list2.val) {
                curr.next = list1;
                list1 = list1.next;
            }
            else {
                curr.next = list2;
                list2 = list2.next;
            }

            curr = curr.next;
        }
        curr.next  = list1 == null? list2:list1;
        return dummy.next;
    }
}
TIME: TODO -
SPACE: TODO -
___________________________________________________________________________________
___________________________________________________________________________________


________________________________String________________________________
______________________________________________________________________
--------------------------------------------------------------20: Valid Parentheses (Easy)
sol1 - --------------
class Solution {
    public boolean isValid(String s) {
       //push starting char onto stack, if not check stack for match

        Stack<Character> stack = new Stack<Character>();
        //foreach loop
        for(char c: s.toCharArray()) {
            //if starting char, push to stack
            if(c == '(' || c == '[' || c == '{') {
                stack.push(c);
            } else if(c == ')' && !stack.isEmpty() && stack.peek() == '(') {
                stack.pop();
            } else if(c == ']' && !stack.isEmpty() && stack.peek() == '[') {
                stack.pop();
            } else if(c == '}' && !stack.isEmpty() && stack.peek() == '{') {
                stack.pop();
            } else {
                return false;
            }
        }
        return stack.isEmpty();
    }
}
TIME: TODO
SPACE: TODO

sol1b - Leetcode solution --------------
public boolean isValid(String s) {
	Stack<Character> stack = new Stack<Character>();
	for (char c : s.toCharArray()) {
		if (c == '(')
			stack.push(')');
		else if (c == '{')
			stack.push('}');
		else if (c == '[')
			stack.push(']');
		else if (stack.isEmpty() || stack.pop() != c)
			return false;
	}
	return stack.isEmpty();
}
TIME: TODO
SPACE: TODO


-------------------------------------424: Longest Repeating Character Replacement (Medium)
sol1 - HashMap, Sliding Window --------------
class Solution {
    public int characterReplacement(String s, int k) {
        char[] arr = s.toCharArray();
        int left = 0, right = 0, n = arr.length;

        //define table
        Map<Character, Integer> map = new HashMap<>();

        //define windowLen and mostFreq
        int maxLen = 0, mostFreq = 0;

        //find longest repeating character replacement
        while(right < n) {
            //Expand window
            map.put(arr[right], map.getOrDefault(arr[right], 0) + 1); //?
            mostFreq = Math.max(mostFreq, map.get(arr[right]));

            //Shrink the window if we need to replace more than k char
            if((right - left + 1) - mostFreq > k) {
                map.put(arr[left], map.get(arr[left]) - 1);
                left++;
            }
            maxLen = Math.max(maxLen, right - left + 1);
            right++;
        }
        return maxLen;
    }
}

TIME: O(n) - O(n*26) = O(n)
SPACE: TODO


_____________________________________________________________________
_____________________________________________________________________

________________________________TREES________________________________
_____________________________________________________________________
NOTE:Tree problems can be solved either recursively or iterativelly. Recursion makes more sense because it is way less code and is generally simplier.

--------------------------------------------------104: Maximum Depth of Binary Tree (Easy)
NOTE: Three approaches, recursive DFS, iterative DFS or BFS. DFS is more common and makes more sense for this problem but BFS
      can be used. It requires use of a queue or a stack.

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */

sol1a - DFS recursive--------------
class Solution {
    public int maxDepth(TreeNode root) {
        //base case
        if(root == null) {
            return 0;
        }

        int left = maxDepth(root.left);
        int right = maxDepth(root.right);
        return Math.max(left, right) + 1;
    }
}
TIME: O(n)
SPACE: O(n)

sol1b - DFS recursive simplified--------------
class Solution {
    public int maxDepth(TreeNode root) {
            if(root==null){
                return 0;
            }
            return Math.max(maxDepth(root.left),maxDepth(root.right)) + 1;
    }
}
TIME: O(n)
SPACE: O(n)

sol2 - BFS iterative-----------------
class Solution {
    public int maxDepth(TreeNode root) {
        if (root == null) return 0;

        int max = 1;

        Stack<TreeNode> nodes = new Stack<>();
        Stack<Integer> depths = new Stack<>();

        nodes.push(root);
        depths.push(1);

        while (!nodes.empty()) {
            TreeNode curr = nodes.pop();
            int depth = depths.pop();

            if (curr.left == null && curr.right == null) {
                max = Math.max(max, depth);
            }

            if (curr.right != null) {
                nodes.push(curr.right);
                depths.push(depth + 1);
            }
            if (curr.left != null) {
                nodes.push(curr.left);
                depths.push(depth + 1);
            }
        }

        return max;

    }
}
TIME: TODO
SPACE: TODO

---------------------------------------------------------------------100: Same Tree (Easy)
Note: always think about the base case when using recursion
sol1a - Recursion--------------
class Solution {
    public boolean isSameTree(TreeNode p, TreeNode q) {
        //base case(s)
        if(p == null && q == null) { // both null so same
            return true;
        } else if(p == null || q == null){ // only 1 null so diff
            return false;
        } else if(p.val != q.val) { // different root values
            return false;
        } else { //actual recursive calls
            return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);
        }
    }
}
TIME: O(n) - traversing the entire tree of both p and q so its 2n which is n
SPACE: O(logn) - best case / O(n) - worst case

sol1b - Recursion simplified--------------
public boolean isSameTree(TreeNode p, TreeNode q) {
    if(p == null && q == null) return true;
    if(p == null || q == null) return false;
    if(p.val == q.val)
        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);
    return false;
}
TIME: TODO
SPACE: TODO

------------------------------------------------------------226: Invert Binary Tree (Easy)
class Solution {
    public TreeNode invertTree(TreeNode root) {
        if(root == null) { //base case, invalid root
            return root;
        }

        //recursion
        TreeNode left = invertTree(root.left);
        TreeNode right = invertTree(root.right);

        //the swap
        root.right = left;
        root.left = right;

        return root;
    }
}
TIME: TODO
SPACE: TODO


-------------------------------------------572: Subtree of Another Tree (Easy *not really)
sol1a - Recursion--------------


TIME: TODO
SPACE: TODO



_____________________________________________________________________
_____________________________________________________________________
