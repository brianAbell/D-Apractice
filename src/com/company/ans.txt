$$BLIND 75$$

________________________________ARRAYS________________________________
______________________________________________________________________

--------------1. Two Sum (Easy)--------------

sol1 - Brute Force 2 pointer solution--------------
class Solution {
    public int[] twoSum(int[] nums, int target) {
        int[] ans = new int[2];
        for(int i = 0; i < nums.length; i++) {
            int curr1 = nums[i];
            for(int j = i+1; j < nums.length; j++) {
                int curr2 = nums[j];
                if(curr1 + curr2 == target) {

                    ans[0] = i;
                    ans[1] = j;
                    return ans;
                }
            }
        }
        return ans;
    }
}
TIME: O(n^2)
SPACE: TODO

sol2 - hashmap--------------
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> visitedNumbers = new HashMap<>();
        for(int i = 0; i < nums.length; i++) {
            // x + y = target
            int delta = target - nums[i];
            if(visitedNumbers.containsKey(delta)) {
                return new int[] {i, visitedNumbers.get(delta)};
            }
            visitedNumbers.put(nums[i], i);
        }
        return new int[] {-1, -1};
    }
}
TIME: O(n)
SPACE: TODO

--------------121. Best Time to Buy and Sell Stock (Easy)--------------

TODO sol1 - Brute Force--------------
public class Solution {
    public int maxProfit(int prices[]) {
        int max = 0;
        for (int i = 0; i < prices.length - 1; i++) {
            for (int j = i + 1; j < prices.length; j++) {
                int profit = prices[j] - prices[i];
                if (profit > max)
                    max = profit;
            }
        }
        return max;
    }
}
TIME: O(n^2)
SPACE: TODO

sol3 - Dynamic Programming--------------
public class Solution {
    public int maxProfit(int[] prices) {
        int max = 0;
        int min = Integer.MAX_VALUE;

        for(int i = 0; i < prices.length; i++) {
            if(prices[i] < min) {
                min = prices[i];
            }
            else if(prices[i] - min > max) {
                max = prices[i] - min;
            }
        }
        return max;
    }
}
TIME: TODO
SPACE: TODO

sol3 - Two pointer efficient--------------
public class Solution {
    public int maxProfit(int[] prices) {
        int max = 0;
        if(prices.length == 0){
            return max;
        }
        int min=prices[0];
        for(int i = 1; i < prices.length; i++){
            if(prices[i] > min){
                if(max < (prices[i] - min)){
                    max=prices[i] - min;
                }
            }
            else{ min = prices[i]; }
        }
        return max;
    }
}
TIME: TODO
SPACE: TODO

--------------217. Contains Duplicate (Easy)--------------

sol1 - Brute Force - linear search took to long though--------------
class Solution {
    public boolean containsDuplicate(int[] nums) {
        int count = 0;

        for(int i = 0; i < nums.length - 1; i++) {
             for(int j = i + 1; j < nums.length; j++) {
                 if(nums[i] == nums[j]) {
                     return true;
                 }
             }
        }
        return false;
    }
}
TIME: O(n^2)
SPACE: TODO

sol2 - Hashsets--------------
class Solution {
    public  boolean containsDuplicate(int[] nums) {
		 Set<Integer> set = new HashSet<Integer>();
		 for(int i : nums)
			 if(!set.add(i))// if there is same
				 return true;
		 return false;
	 }
}
TIME: O(n)
SPACE: O(n)

TODO sol3 - idk yet


--------------238: Product of Array Except Self (Medium)--------------




______________________________________________________________________
______________________________________________________________________


________________________________BINARY________________________________
______________________________________________________________________
--------------371. Sum of Two Integers (Medium)--------------
TODO

--------------191. Number of 1 Bits (Easy)--------------
sol1 - Brute Force--------------


TIME: TODO
SPACE: TODO



______________________________________________________________________
______________________________________________________________________

________________________________DYNAMIC PROGRAMMING________________________________
___________________________________________________________________________________

--------------70: Climbing Stairs (Easy)--------------
sol1 - Brute Force--------------


TIME: TODO
SPACE: TODO


sol2 - The Fastest time complexity, not using array----------------
public int climbStairs(int n) {
    //base cases
    if(n == 1) return 1;
    if(n == 2) return 2;

    //rest
    int a = 1;
    int b = 2;
    int ways = 0;

    for(int i = 2; i < n; i++) {
        ways = a + b;
        a = b;
        b = ways;
    }
    return ways;
}
TIME: TODO
SPACE: TODO

sol3 - The Fastest time complexity, using array---------
public int climbStairs(int n) {
        int[] dp = new int[n+1];
        dp[0]=1;
        dp[1]=1;
        for(int i = 2; i <= n; i++) {
            dp[i] = dp[i-1] + dp[i-2];
        }
        return dp[n];
}
TIME: TODO
SPACE: TODO

___________________________________________________________________________________
___________________________________________________________________________________

________________________________Graph________________________________
_____________________________________________________________________

TODO

___________________________________________________________________________________
___________________________________________________________________________________

________________________________Interval________________________________
________________________________________________________________________

TODO

___________________________________________________________________________________
___________________________________________________________________________________

________________________________Linked List________________________________
___________________________________________________________________________

--------------206: Reverse Linked List (Easy)--------------
sol1 - Brute Force, iterative--------------
NOTE: singly linked lists prevent traversing backwards so our solution requires us to keep track of the prev node.

public ListNode reverseList(ListNode head) {
        ListNode prev = null; //init pointer
        ListNode next = null; //init pointer

        while(head != null) {
            next = head.next; //save next
            head.next = prev; //reverse
            prev = head; //advance prev & head
            head = next; //advance prev & head
        }
        return prev; //new head at end
}
TIME: O(n)
SPACE: O(1) / O(n)

sol2 - Recursive--------------

// 1 -> 2 -> 3
// 3 -> 2 -> 1

public ListNode reverseList(ListNode head) {
    return reverseListInt(head, null);
}

public ListNode reverseListInt(ListNode head, ListNode newHead) {
    if(head == null) {return newHead;}
    ListNode next = head.next;
    head.next = newHead;
    return reverseListInt(next, head);
}
TIME: O(n)
SPACE: O(n)

--------------141: Linked List Cycle (Easy)--------------
sol1 - Brute Force, iterative--------------

TIME: TODO
SPACE: TODO

sol2 - Recursive--------------

TIME: TODO
SPACE: TODO
___________________________________________________________________________________
___________________________________________________________________________________