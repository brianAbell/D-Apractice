___________________________________ARRAY_______________________________________________
_______________________________________________________________________________________
Easy | 1. Two Sum----------------------------------------------------------------------------
approach 1: Brute Force--------------
Description:    Loop through each element x and find if there is another value
                that equals to 'target-x'

class Solution {
    public int[] twoSum(int[] nums, int target) {
        for (int i = 0; i < nums.length; i++) {
            for (int j = i + 1; j < nums.length; j++) {
                if (nums[j] == target - nums[i]) {
                    return new int[] { i, j };
                }
            }
        }
        // In case there is no solution, we'll just return null
        return null;
    }
}
TIME: O(n^2):   For each element, we try to find its complement by looping through the rest
                of the array which takes O(n) time. Therefore, the TC is O(n^2).
SPACE: O(1):    The space required does not depend on the size of the input array,
                so only constant space is used.

approach 2: One-pass(used once) Hash Table--------------
Description:    It turns out we can do it in one-pass. While we are iterating and
                inserting elements into the hash table, we also look back to check if
                current element's complement already exists in the hash table. If it
                exists, we have found a solution and return the indices immediately.

class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < nums.length; i++) {
            int complement = target - nums[i];
            if (map.containsKey(complement)) {
                return new int[] { map.get(complement), i };
            }
            map.put(nums[i], i);
        }
        // In case there is no solution, we'll just return null
        return null;
    }
}
TIME: O(n): We traverse the list containing n elements only once. Each loopup in the
            table costs only O(1) time.
SPACE: O(n):    The extra space required depends on the number of items stored in the hash
                table, which stores at most n elements.

Easy | 121. Best Time to Buy and Sell Stock----------------------------------------------------------------------------
approach 1: Brute force--------------
Description:    We need to find out the maximum difference (which will be the
                maximum profit) between two numbers in the given array. Also,
                the second number (selling price) must be larger than the first
                one (buying price).

class Solution {
    public int maxProfit(int[] prices) {
       //get track of curr max profit
        int currmax = 0;

        // 1  3  4  2  8
        // i     j
        //profit -> 4 - 1 = 3

        //iterate through with pointer 1 (buy)
        for(int i = 0; i < prices.length - 1; i++) {
            //iterate through with pointer 2 (sell)
            for(int j = i + 1; j < prices.length; j++) {
                //the calculated profit
                int profit = prices[j] - prices[i];
                //if profit is bigger than saved max, replace max
                if (profit > currmax) {
                    currmax = profit;
                }
            }
        }
        //finally return the max
        return currmax;
    }
}
TIME: O(n^2): Loop runs (n(2-1))/2 times.
SPACE: O(1): Only two variables - 'maxprofit' and 'profit' are used.

approach 2: One Pass--------------
Description:    For every element, we are calculating the difference
                between that element and the minimum of all the values
                before that element and we are updating the maximum profit
                if the difference thus found is greater than the current
                maximum profit.

//1  2  6
//minprice=1
//maxprofit=5
//return 5
class Solution {
    public int maxProfit(int[] prices) {
        //used to store min found price and max profit
        int minprice = Integer.MAX_VALUE;
        int maxprofit = 0;

        //iterate through array
        for(int i = 0; i < prices.length; i++) {
            //check if the current price is less than saved min price
            if (prices[i] < minprice)
                minprice = prices[i];

            //check if the difference between current price and minprice
            // is larger than maxprofit
            else if (prices[i] - minprice > maxprofit)
                maxprofit = prices[i] - minprice;
        }
        //return the final maxprofit
        return maxprofit;
    }
}
TIME: O(n): Only a single pass needed.
SPACE: O(1): Only two variables are used.
Easy | Contains Duplicate----------------------------------------------------------------------------
approach 1: Iterative--------------

Easy | Product of Array Except Self----------------------------------------------------------------------------
approach 1: Iterative--------------

Easy | Maximum Subarray----------------------------------------------------------------------------
approach 1: Iterative--------------

Medium | Maximum Product Subarray----------------------------------------------------------------------------
approach 1: Iterative--------------

Medium | Find Minimum in Rotated Sorted Array----------------------------------------------------------------------------
approach 1: Iterative--------------

Medium | Search in Rotated Sorted Array----------------------------------------------------------------------------
approach 1: Iterative--------------

Medium | 3Sum----------------------------------------------------------------------------
approach 1: Iterative--------------

Medium | Container With Most Water----------------------------------------------------------------------------
approach 1: Iterative--------------


___________________________________BINARY______________________________________________
_______________________________________________________________________________________

sol1 - iterative--------------

_____________________________DYNAMIC PROGRAMMING_______________________________________
_______________________________________________________________________________________

sol1 - iterative--------------

___________________________________GRAPH_______________________________________________
_______________________________________________________________________________________

sol1 - iterative--------------

__________________________________INTERVAL_____________________________________________
_______________________________________________________________________________________

sol1 - iterative--------------

_________________________________LINKED LIST___________________________________________
_______________________________________________________________________________________

sol1 - iterative--------------

___________________________________MATRIX______________________________________________
_______________________________________________________________________________________

sol1 - iterative--------------

___________________________________STRING______________________________________________
_______________________________________________________________________________________

sol1 - iterative--------------
___________________________________TREE________________________________________________
_______________________________________________________________________________________

sol1 - iterative--------------

___________________________________HEAP________________________________________________
_______________________________________________________________________________________

sol1 - iterative--------------





